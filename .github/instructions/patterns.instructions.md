## 核心设计模式

### 规则：识别并应用正确的缓存模式

本项目的核心是探索两种缓存策略。在修改代码，特别是 `internal/data` 层时，你必须首先识别当前代码属于哪种模式，并严格遵守该模式的规则。

#### 模式一：同步旁路缓存 (应用层负责)

- **识别方法**:
  - 在 `internal/data` 的写入方法（如 `Update`、`Delete`）中，你会看到对 `gocache` 的 `Delete()` 或 `Invalidate()` 的显式调用。
  - `biz` 层的 `Repo` 接口定义中，写入方法可能会返回 `error`，暗示需要处理缓存操作的结果。

- **你的任务**:
  - **保持模式**: 当你修改这些方法时，必须维持 **“先写数据库，再删缓存”** 的顺序。
  - **原子性**: 数据库操作和缓存操作应被视为一个整体，尽管它们不是事务性的。确保在数据库写入成功后才执行缓存失效。
  - **参考实现**: 查看 `internal/data/user.go` (如果存在) 中的写入操作，那里会有该模式的典型实现。

#### 模式三：RAG 数据流架构 (Go 微服务 + Python AI 服务)

- **识别方法**:
  - 涉及 Kafka 消息队列、Flink 流处理、Elasticsearch 向量搜索的代码
  - Go 服务调用 Python AI 服务的 HTTP 接口
  - 包含向量化处理和索引写入逻辑

- **你的任务**:
  - **数据写入职责**: Go 微服务负责消费富化数据、向量化处理和 Elasticsearch 索引写入
  - **数据读取职责**: Go 服务调用 Python AI 服务进行向量检索和答案生成
  - **协作模式**: 明确 Go/Python 服务边界，Go 负责数据管道，Python 负责 AI 计算
  - **错误处理**: 实现熔断、重试和超时控制机制
