## 核心设计模式

### 规则：识别并应用正确的缓存模式

本项目的核心是探索两种缓存策略。在修改代码，特别是 `internal/data` 层时，你必须首先识别当前代码属于哪种模式，并严格遵守该模式的规则。

#### 模式一：同步旁路缓存 (应用层负责)

- **识别方法**:
  - 在 `internal/data` 的写入方法（如 `Update`、`Delete`）中，你会看到对 `gocache` 的 `Delete()` 或 `Invalidate()` 的显式调用。
  - `biz` 层的 `Repo` 接口定义中，写入方法可能会返回 `error`，暗示需要处理缓存操作的结果。

- **你的任务**:
  - **保持模式**: 当你修改这些方法时，必须维持 **“先写数据库，再删缓存”** 的顺序。
  - **原子性**: 数据库操作和缓存操作应被视为一个整体，尽管它们不是事务性的。确保在数据库写入成功后才执行缓存失效。
  - **参考实现**: 查看 `internal/data/user.go` (如果存在) 中的写入操作，那里会有该模式的典型实现。

#### 模式二：异步缓存失效 (CDC + Flink 负责)

- **识别方法**:
  - `internal/data` 的写入方法**只包含数据库操作** (例如，调用 GORM 的 `Save()` 或 `Update()`)，完全没有 `gocache` 的失效代码。
  - `biz` 层的 `Repo` 接口定义中，写入方法可能没有返回值或只返回 `error`，且与缓存无关。

- **你的任务**:
  - **严禁添加缓存逻辑**: 在此模式下，**绝对不要**在 Kratos 应用的任何代码中添加缓存失效逻辑。缓存是由外部的 Flink 作业通过监听数据库变更日志来处理的。
  - **专注数据一致性**: 你的唯一职责是确保数据库操作的正确性和原子性。
